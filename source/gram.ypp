%{
#include <iostream>
#include <string>
#include <map>
#include <stack>
#include <vector>
#include <cstring>
#include <set>
#include <cstdlib>
#include <algorithm>
#include <sstream>

#include <fstream>
#include <string>

using namespace std;

int yylex(); 
void yyerror(const char *s) { fprintf (stderr, "ERROR %s\n", s); }

void warning(string s) {
    cout << "[Warning] " << s << "\n";
}

void error(string s) {
    cout << "[Error] " << s << "\n";
    exit(0);
}

struct State {
    string id;
    vector<string> edges;
    string comment;
    bool is_terminal;
};


struct Edge {
    string id;
    vector<string> allowed_letters;
    string end;
};

string quote(string s) {
    return "'" + s + "'";
}


template<typename T>
class Parameter {
    string field_name;
    T value;
    bool assigned = false;
public:
    Parameter(){}

    Parameter(string f_n) {
        field_name = f_n;
    }

    void set(T other) {
        if(assigned) {
            error(field_name  + " must be defined only one time");
        }

        value = other;
        assigned = true;
    }

    void reset() {
        assigned = false;
        value = T();
    } 

    bool is_assigned() {
        return assigned;
    }

    T get_value() {
        return value;
    }
};

struct Automata {
    Parameter<vector<string>> alphabet_list = "_Alphabet"s, states_list = "_States"s, edges_list = "_Edges"s;
    map<string, Edge> edges;
    map<string, State> states;
    Parameter<string> q0 = "_Q0"s; 

    void add_edge(Edge e) {
        edges[e.id] = e;
    }

    void add_state(State s) {
        states[s.id] = s;
    }

    void validate() {
        map<string, bool> existing_letters;
        map<string, bool> existing_states;
        map<string, bool> existing_edges;
        set<string> sorted_alphabet;
        for(auto x: alphabet_list.get_value()) {
            existing_letters[x] = true;
            sorted_alphabet.insert(x);
        }

        for(auto x: states_list.get_value()) {
            existing_states[x] = true;
        }

        for(auto x: edges_list.get_value()) {
            existing_edges[x] = true;
        }

        if(q0.get_value().empty()) {
            error("Start state is not set");
        }

        for(auto x: existing_states) {
            string state_id = x.first;
            set<string> letters;
            map<string, bool> used_letters;

            for(auto e_id: states[state_id].edges) {
                for(auto w: edges[e_id].allowed_letters) {
                    if(used_letters[w]) {
                        error("One letter can't be used in two edges. State " + quote(state_id) + ".");
                    }

                    letters.insert(w);
                    used_letters[w] = true;
                }
            }

            if (sorted_alphabet != letters) {
                warning("Automata is not full. State id " + quote(state_id));
            }
        }
    }

    pair<int, State*> check(vector<string> letters) {
        string curr_s = q0.get_value();
        for(auto letter: letters) {
            bool next_state_is_found = false;
            for(auto edge_id: states[curr_s].edges) {
                const auto &edge = edges[edge_id];
                if(find(edge.allowed_letters.begin(), edge.allowed_letters.end(), letter) != edge.allowed_letters.end()) {
                    next_state_is_found = true;
                    curr_s = edge.end;
                    break;
                } 
            }
            
            if(!next_state_is_found) {
                return make_pair(-1, nullptr);
            }
        }


        return make_pair(states[curr_s].is_terminal ? 1 : 0, &states[curr_s]);
    }
};

Automata & automata() {
    static Automata automata;
    return automata;
}


struct Parser {
    vector <string> variables; 

    Parameter<vector<string>> allowed_letters = "__allowed_letters"s;
    Parameter<string> end = "__end"s;
    
    Parameter<vector<string>> edges = "__edges"s;
    Parameter<string> comment = "__comment"s;
    Parameter<bool> is_terminal = "__is_terminal"s;

    void add_variable(string s) {
        variables.push_back(s);
    }
    void set_allowed_letters() {
        allowed_letters.set(variables);
        variables.clear();
    }
    
    void set_end(string v) {
        end.set(v);
    } 

    void set_edges() {
        edges.set(variables);
        variables.clear();
    }

    void set_is_terminal(int flag) {
        is_terminal.set(flag);
    }

    void set_comment(string s) {
        comment.set(s); 
    }


    void initialize(string s) {
        sort(variables.begin(), variables.end());
        for(int i = 0; i + 1 < variables.size(); i++) {
            if(variables[i] == variables[i + 1]) {
                warning("All elements " + s + " should be unique");
            }
        }

        if(s == "_Alphabet") {
            automata().alphabet_list.set(variables);
        } else if( s == "_States") {
            automata().states_list.set(variables);
        } else if (s == "_Edges") {
            automata().edges_list.set(variables);
        } else if(s == "_Q0") {
            if(variables.size() != 1) {
                error("QO must be inizializate by one state");
            }
            automata().q0.set(variables[0]);
        }

        variables.clear();
    }

    void add_edge(string id) {
        Edge res;
        res.id = id;
        if(!allowed_letters.is_assigned()) {
            error("Edge with id " + quote(id) + " doesn't have field __allowed_letters");
        } else {
            res.allowed_letters = allowed_letters.get_value();
            if(res.allowed_letters.empty()) {
                error("Edge with id " + quote(id) + " has empty __allowed_letters");
            } 
        }

        allowed_letters.reset();
        
        if(!end.is_assigned()) {
            error("Edge with id " + quote(id) + "doesn't have field end");
        }

        res.end = end.get_value();
        end.reset();
        
        automata().add_edge(res);
    }


    void add_state(string id) {
        State res;
        res.id = id;

        if(edges.is_assigned()) {
            res.edges = edges.get_value();   
        }
        
        edges.reset();

        if(comment.is_assigned()) {
            res.comment = comment.get_value();
        }
        comment.reset();

        if(!is_terminal.is_assigned()) {
            error("State with id " + id + " doesn't have __is_terminal field");
        }

        res.is_terminal = is_terminal.get_value();
        is_terminal.reset();

        automata().add_state(res);
    }


};


Parser& parser() {
  static Parser res;
  return res;
}


%}

%union {
    const char *str;
};


%token T_NEW
%token <str> T_INITIALIZATION_VARIABLE
%token <str> T_VARIABLE 

%token T_STATE
%token T_EDGES_STATE_FIELD
%token T_COMMENT_STATE_FIELD
%token T_IS_TERMINAL_STATE_FIELD

%token T_EDGE 
%token T_ALLOWED_LETTERS_EDGE_FIELD 
%token T_END_EDGE_FIELD


%token <str> T_BOOLEAN
%token <str> T_STRING
%token T_OPEN_CURLY_BRACKET  
%token T_CLOSE_CURLY_BRACKET
%token T_OPEN_ROUND_BRACKET
%token T_CLOSE_ROUND_BRACKET
%token T_COLON
%token T_EMPTY_LINE
%token <str> T_SPACES
%token T_COMM
%token T_DOT
%token <number> T_EOF

%type <str> SPACED_VARIABLE


%%


start: %empty
       | T_EMPTY_LINE start
       | initialization start 
       | add_edge start
       | add_state start


add_edge: spaces T_NEW spaces T_EDGE T_OPEN_ROUND_BRACKET SPACED_VARIABLE T_CLOSE_ROUND_BRACKET spaces T_COLON edge_fields { parser().add_edge($6);}


edge_fields: %empty  
            | T_EMPTY_LINE edge_fields
            | edge_field edge_fields

edge_field: T_EMPTY_LINE edge_field
            | spaces T_ALLOWED_LETTERS_EDGE_FIELD spaces T_COLON spaces enumeration_list { parser().set_allowed_letters(); }
            | spaces T_END_EDGE_FIELD spaces T_COLON spaces T_VARIABLE spaces { parser().set_end($6);}


add_state: spaces T_NEW spaces T_STATE T_OPEN_ROUND_BRACKET SPACED_VARIABLE T_CLOSE_ROUND_BRACKET spaces T_COLON state_fields { parser().add_state($6);} 


state_fields: %empty  
              | T_EMPTY_LINE state_fields
              | state_field state_fields

state_field:  T_EMPTY_LINE state_field
              | spaces T_EDGES_STATE_FIELD spaces T_COLON spaces enumeration_list  {parser().set_edges();}
              | spaces T_COMMENT_STATE_FIELD spaces T_COLON spaces T_STRING {parser().set_comment($6);}
              | spaces T_IS_TERMINAL_STATE_FIELD spaces T_COLON spaces T_BOOLEAN { string s = $6; if(s == "True") parser().set_is_terminal(1); else parser().set_is_terminal(0);}



initialization: T_INITIALIZATION_VARIABLE spaces enumeration_list { parser().initialize($1); }


enumeration_list: T_OPEN_CURLY_BRACKET sequence T_CLOSE_CURLY_BRACKET {}

sequence: %empty
          | SPACED_VARIABLE skip_empty_lines { parser().add_variable($1);}
          | SPACED_VARIABLE T_COMM sequence { parser().add_variable($1);} 
          | T_EMPTY_LINE sequence {}

SPACED_VARIABLE: spaces T_VARIABLE spaces { $$ = $2;} 

skip_empty_lines: %empty    
                  | T_EMPTY_LINE skip_empty_lines
                  | spaces skip_empty_lines
spaces: %empty
        | T_SPACES

%%

int main(int argc, char* argv[]) {
    if (argc < 3) { 
        printf("Arguments are not enough");
        return 1;
    }
    
    try {
        freopen(argv[1], "r", stdin);
        std::cout << "-----------------------Creating automata------------------------"  << "\n";   
        yyparse();
        automata().validate();
        std::cout << "----------------Automata is created successfully----------------"  << "\n\n\n";
        
        
        std::cout << "Start testing file: " << quote(argv[2]) << "\n\n";

        freopen(argv[2], "r", stdin);
        std::string input;
        int test = 1;
        while(std::getline(std::cin, input)) {
            std::stringstream ist(input);
            std::cout << "TEST #" << test << ": " << input << "\n";
            vector<string> letters;
            for (std::string word; ist >> word; ) {
                letters.push_back(word);
            }
            auto res = automata().check(letters);

            if(res.first == 1) {
                std::cout << "True | Final state: " << (res.second->id) << " | " << (res.second->comment) << "\n";
            } 
            else if(res.first == 0) {
                std::cout << "False | Final state: " << res.second->id << " | " << res.second->comment << "\n";
            } else if(res.first == -1){
                std::cout << "False | Final state: " << "None" << "\n";
            }
            test++;
            std::cout << "\n";
        }


    } catch(std::exception &e) {
        std::cout << e.what() << '\n';
        return 1;
    }

    return 0;
}